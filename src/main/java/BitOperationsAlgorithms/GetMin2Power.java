package BitOperationsAlgorithms;

import org.junit.Test;

public class GetMin2Power {
    /**
     * 题目介绍
     * 任意给定一个数，返回大于等于它的最小的2的整数次幂。
     *
     * 思路分析：
     *    主要思想：将该数最高位为1及之下的位全部设为1，然后加1返回即可。
     * 第一部分：保证所求最小的2的整数次幂中比特是1的那个比特位的紧挨着后面那个比特必须是1,且是第一个为1的比特。
     * n = n-1 的目的主要是针对n恰好是2的乘方。如0100,0000，需要减1，变成0011,1111;
     *       若n不是2的整数次幂，减1或减1都无所谓的，如0100,1000;减1变成0100,0111;
     * n= n-1的目的是保证所求最小的2的整数次幂中比特是1的那个比特位的紧挨着后面那个比特必须是1,且是第一个为1的比特。
     *      如0100,0000必须保证第3比特为1且是为1的第一个比特，如0011,0000;
     *      0100,1000必须保证第2比特为1且是为1的第一个比特，如0100,0111;
     * 第二部分：
     *      前提：第一部分已经保证了所求结果的为1的比特位的后面一位已经为1了。
     *      那么，右移1位然后再与，保证连续两位为1；
     *      再右移2位后再与，保证连续四位为1；
     *      再右移4位后再与，保证连续八位为1；
     *      再右移8位后再与，保证连续16位为1；
     *      再右移16位后再与，保证连续32位为1；
     *      最终肯定是保证了所需结果的为1的比特位的后面所有位都是1.
     * 之前的理解:
     *      若原数已经是2的幂，则只有一位为1，减1之后，得到后面的位全是1，下面不断右移再或，最后也是全是1，加1后恢复原值；
     *      若原数值不是2的幂，则减1之后，最高位1不变，然后先右移一位之后与原值或操作，则保证高两位全为1，
     *      再右移2位后与原值或操作，可以得到高四为全为1，紧接着右移4位再或，得到高8位为1，依次类推，
     *      最终可以所有数的后面位全为1。当然大多数不需要移动这么多位，为了保证全面性。
     */
    public int getMin2Power(int n){
        n = n - 1;//保证结果的位1的比特位的后一位必须为1
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0)?1:n+1;
    }

    @Test
    public void test(){
        System.out.println("getMin2Power(13) = " + getMin2Power(13));
        System.out.println("getMin2Power(13) = " + getMin2Power(16));
    }

}
